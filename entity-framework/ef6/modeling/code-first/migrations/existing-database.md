---
title: 使用现有数据库 Code First 迁移-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: f0cc4f93-67dd-4664-9753-0a9f913814db
ms.openlocfilehash: eb7948eafb1322cabcf69b47bd5411f762fe8498
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78415693"
---
# <a name="code-first-migrations-with-an-existing-database"></a><span data-ttu-id="36cc6-102">使用现有数据库 Code First 迁移</span><span class="sxs-lookup"><span data-stu-id="36cc6-102">Code First Migrations with an existing database</span></span>
> [!NOTE]
> <span data-ttu-id="36cc6-103">**Ef 4.3 仅向前**-在实体框架4.1 中引入了本页中所述的功能、api 等。</span><span class="sxs-lookup"><span data-stu-id="36cc6-103">**EF4.3 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 4.1.</span></span> <span data-ttu-id="36cc6-104">如果使用的是早期版本，则部分或全部信息不适用。</span><span class="sxs-lookup"><span data-stu-id="36cc6-104">If you are using an earlier version, some or all of the information does not apply.</span></span>

<span data-ttu-id="36cc6-105">本文介绍如何将 Code First 迁移与现有数据库（不是由实体框架创建的数据库）结合使用。</span><span class="sxs-lookup"><span data-stu-id="36cc6-105">This article covers using Code First Migrations with an existing database, one that wasn’t created by Entity Framework.</span></span>

> [!NOTE]
> <span data-ttu-id="36cc6-106">本文假设你知道如何在基本方案中使用 Code First 迁移。</span><span class="sxs-lookup"><span data-stu-id="36cc6-106">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="36cc6-107">如果没有，则需要先阅读[Code First 迁移](~/ef6/modeling/code-first/migrations/index.md)，然后再继续。</span><span class="sxs-lookup"><span data-stu-id="36cc6-107">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="screencasts"></a><span data-ttu-id="36cc6-108">屏幕广播</span><span class="sxs-lookup"><span data-stu-id="36cc6-108">Screencasts</span></span>

<span data-ttu-id="36cc6-109">如果你想要观看 screencast 而不是阅读本文，以下两个视频会涵盖与本文相同的内容。</span><span class="sxs-lookup"><span data-stu-id="36cc6-109">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="36cc6-110">视频一： "迁移-在后台"</span><span class="sxs-lookup"><span data-stu-id="36cc6-110">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="36cc6-111">[此 screencast](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood)介绍了迁移如何跟踪并使用有关模型的信息来检测模型更改。</span><span class="sxs-lookup"><span data-stu-id="36cc6-111">[This screencast](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---existing-databases"></a><span data-ttu-id="36cc6-112">视频两个： "迁移-现有数据库"</span><span class="sxs-lookup"><span data-stu-id="36cc6-112">Video Two: "Migrations - Existing Databases"</span></span>

<span data-ttu-id="36cc6-113">基于前一视频中的概念生成，[此 screencast](https://channel9.msdn.com/blogs/ef/migrations-existing-databases)介绍了如何启用和使用现有数据库的迁移。</span><span class="sxs-lookup"><span data-stu-id="36cc6-113">Building on the concepts from the previous video, [this screencast](https://channel9.msdn.com/blogs/ef/migrations-existing-databases) covers how to enable and use migrations with an existing database.</span></span>

## <a name="step-1-create-a-model"></a><span data-ttu-id="36cc6-114">步骤1：创建模型</span><span class="sxs-lookup"><span data-stu-id="36cc6-114">Step 1: Create a model</span></span>

<span data-ttu-id="36cc6-115">第一步是创建一个面向现有数据库的 Code First 模型。</span><span class="sxs-lookup"><span data-stu-id="36cc6-115">Your first step will be to create a Code First model that targets your existing database.</span></span> <span data-ttu-id="36cc6-116">" [Code First 现有数据库](~/ef6/modeling/code-first/workflows/existing-database.md)" 主题提供有关如何执行此操作的详细指导。</span><span class="sxs-lookup"><span data-stu-id="36cc6-116">The [Code First to an Existing Database](~/ef6/modeling/code-first/workflows/existing-database.md) topic provides detailed guidance on how to do this.</span></span>

>[!NOTE]
> <span data-ttu-id="36cc6-117">在对模型进行任何需要更改数据库架构的更改之前，请务必遵循本主题中的其余步骤。</span><span class="sxs-lookup"><span data-stu-id="36cc6-117">It is important to follow the rest of the steps in this topic before making any changes to your model that would require changes to the database schema.</span></span> <span data-ttu-id="36cc6-118">以下步骤要求模型与数据库架构保持同步。</span><span class="sxs-lookup"><span data-stu-id="36cc6-118">The following steps require the model to be in-sync with the database schema.</span></span>

## <a name="step-2-enable-migrations"></a><span data-ttu-id="36cc6-119">步骤2：启用迁移</span><span class="sxs-lookup"><span data-stu-id="36cc6-119">Step 2: Enable Migrations</span></span>

<span data-ttu-id="36cc6-120">下一步是启用迁移。</span><span class="sxs-lookup"><span data-stu-id="36cc6-120">The next step is to enable migrations.</span></span> <span data-ttu-id="36cc6-121">可以通过在 Package Manager Console 中运行 "**启用-迁移**" 命令来执行此操作。</span><span class="sxs-lookup"><span data-stu-id="36cc6-121">You can do this by running the **Enable-Migrations** command in Package Manager Console.</span></span>

<span data-ttu-id="36cc6-122">此命令将在你的解决方案中创建一个名为 "迁移" 的文件夹，并在其中放置一个名为 "配置" 的类。</span><span class="sxs-lookup"><span data-stu-id="36cc6-122">This command will create a folder in your solution called Migrations, and put a single class inside it called Configuration.</span></span> <span data-ttu-id="36cc6-123">配置类是你为应用程序配置迁移的位置，你可以在[Code First 迁移](~/ef6/modeling/code-first/migrations/index.md)主题中找到有关它的详细信息。</span><span class="sxs-lookup"><span data-stu-id="36cc6-123">The Configuration class is where you configure migrations for your application, you can find out more about it in the [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) topic.</span></span>

## <a name="step-3-add-an-initial-migration"></a><span data-ttu-id="36cc6-124">步骤3：添加初始迁移</span><span class="sxs-lookup"><span data-stu-id="36cc6-124">Step 3: Add an initial migration</span></span>

<span data-ttu-id="36cc6-125">创建迁移并将迁移应用到本地数据库后，您可能还需要将这些更改应用到其他数据库。</span><span class="sxs-lookup"><span data-stu-id="36cc6-125">Once migrations have been created and applied to the local database you may also want to apply these changes to other databases.</span></span> <span data-ttu-id="36cc6-126">例如，您的本地数据库可能是一个测试数据库，您可能最终还需要对生产数据库和/或其他开发人员测试数据库应用所做的更改。</span><span class="sxs-lookup"><span data-stu-id="36cc6-126">For example, your local database may be a test database and you may ultimately want to also apply the changes to a production database and/or other developers test databases.</span></span> <span data-ttu-id="36cc6-127">此步骤有两个选项，应选择的选项取决于任何其他数据库的架构是否为空，或当前是否与本地数据库的架构匹配。</span><span class="sxs-lookup"><span data-stu-id="36cc6-127">There are two options for this step and the one you should pick depends whether or not the schema of any other databases is empty or currently matches the schema of the local database.</span></span>

-   <span data-ttu-id="36cc6-128">**选项一：使用现有架构作为起始点。**</span><span class="sxs-lookup"><span data-stu-id="36cc6-128">**Option One: Use existing schema as starting point.**</span></span> <span data-ttu-id="36cc6-129">如果将来将应用迁移到的其他数据库将具有与本地数据库当前具有的架构相同的架构，则应使用此方法。</span><span class="sxs-lookup"><span data-stu-id="36cc6-129">You should use this approach when other databases that migrations will be applied to in the future will have the same schema as your local database currently has.</span></span> <span data-ttu-id="36cc6-130">例如，如果本地测试数据库当前与生产数据库的 v1 相匹配，则可以使用此项，稍后会应用这些迁移，将生产数据库更新为 v2。</span><span class="sxs-lookup"><span data-stu-id="36cc6-130">For example, you might use this if your local test database currently matches v1 of your production database and you will later apply these migrations to update your production database to v2.</span></span>
-   <span data-ttu-id="36cc6-131">**选项2：使用空数据库作为起始点。**</span><span class="sxs-lookup"><span data-stu-id="36cc6-131">**Option Two: Use empty database as starting point.**</span></span> <span data-ttu-id="36cc6-132">如果将来将应用迁移的其他数据库为空（或尚不存在），则应使用此方法。</span><span class="sxs-lookup"><span data-stu-id="36cc6-132">You should use this approach when other databases that migrations will be applied to in the future are empty (or do not exist yet).</span></span> <span data-ttu-id="36cc6-133">例如，如果使用测试数据库开始开发应用程序，但不使用迁移，则可以使用此示例，以后要从头开始创建生产数据库。</span><span class="sxs-lookup"><span data-stu-id="36cc6-133">For example, you might use this if you started developing your application using a test database but without using migrations and you will later want to create a production database from scratch.</span></span>

### <a name="option-one-use-existing-schema-as-a-starting-point"></a><span data-ttu-id="36cc6-134">选项一：使用现有架构作为起始点</span><span class="sxs-lookup"><span data-stu-id="36cc6-134">Option One: Use existing schema as a starting point</span></span>

<span data-ttu-id="36cc6-135">Code First 迁移使用最新迁移中存储的模型的快照来检测对模型所做的更改（可在[团队环境中 Code First 迁移](~/ef6/modeling/code-first/migrations/teams.md)找到有关此内容的详细信息）。</span><span class="sxs-lookup"><span data-stu-id="36cc6-135">Code First Migrations uses a snapshot of the model stored in the most recent migration to detect changes to the model (you can find detailed information about this in [Code First Migrations in Team Environments](~/ef6/modeling/code-first/migrations/teams.md)).</span></span> <span data-ttu-id="36cc6-136">由于我们将假设数据库已具有当前模型的架构，因此，我们将生成一个将当前模型作为快照的空（无操作）迁移。</span><span class="sxs-lookup"><span data-stu-id="36cc6-136">Since we are going to assume that databases already have the schema of the current model, we will generate an empty (no-op) migration that has the current model as a snapshot.</span></span>

1.  <span data-ttu-id="36cc6-137">在 Package Manager Console 中运行**Add-迁移 InitialCreate – IgnoreChanges**命令。</span><span class="sxs-lookup"><span data-stu-id="36cc6-137">Run the **Add-Migration InitialCreate –IgnoreChanges** command in Package Manager Console.</span></span> <span data-ttu-id="36cc6-138">这将创建一个空迁移，并将当前模型作为快照。</span><span class="sxs-lookup"><span data-stu-id="36cc6-138">This creates an empty migration with the current model as a snapshot.</span></span>
2.  <span data-ttu-id="36cc6-139">在 Package Manager Console 中运行 "**更新数据库**" 命令。</span><span class="sxs-lookup"><span data-stu-id="36cc6-139">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="36cc6-140">这会将 InitialCreate 迁移应用到数据库。</span><span class="sxs-lookup"><span data-stu-id="36cc6-140">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="36cc6-141">由于实际迁移并不包含任何更改，因此只需将一行添加到 \_\_MigrationsHistory 表，指出已应用此迁移。</span><span class="sxs-lookup"><span data-stu-id="36cc6-141">Since the actual migration doesn’t contain any changes, it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>

### <a name="option-two-use-empty-database-as-a-starting-point"></a><span data-ttu-id="36cc6-142">选项2：使用空数据库作为起始点</span><span class="sxs-lookup"><span data-stu-id="36cc6-142">Option Two: Use empty database as a starting point</span></span>

<span data-ttu-id="36cc6-143">在此方案中，我们需要迁移才能从头开始创建整个数据库（包括本地数据库中已存在的表）。</span><span class="sxs-lookup"><span data-stu-id="36cc6-143">In this scenario we need Migrations to be able to create the entire database from scratch – including the tables that are already present in our local database.</span></span> <span data-ttu-id="36cc6-144">我们将生成一个 InitialCreate 迁移，其中包含用于创建现有架构的逻辑。</span><span class="sxs-lookup"><span data-stu-id="36cc6-144">We’re going to generate an InitialCreate migration that includes logic to create the existing schema.</span></span> <span data-ttu-id="36cc6-145">然后，将使现有的数据库看起来像此迁移已应用。</span><span class="sxs-lookup"><span data-stu-id="36cc6-145">We’ll then make our existing database look like this migration has already been applied.</span></span>

1.  <span data-ttu-id="36cc6-146">在 Package Manager Console 中运行**Add-迁移 InitialCreate**命令。</span><span class="sxs-lookup"><span data-stu-id="36cc6-146">Run the **Add-Migration InitialCreate** command in Package Manager Console.</span></span> <span data-ttu-id="36cc6-147">这将创建一个迁移来创建现有架构。</span><span class="sxs-lookup"><span data-stu-id="36cc6-147">This creates a migration to create the existing schema.</span></span>
2.  <span data-ttu-id="36cc6-148">注释掉新创建的迁移的 Up 方法中的所有代码。</span><span class="sxs-lookup"><span data-stu-id="36cc6-148">Comment out all code in the Up method of the newly created migration.</span></span> <span data-ttu-id="36cc6-149">这样，我们就可以 "应用" 将迁移到本地数据库，而无需尝试重新创建所有表，等等。</span><span class="sxs-lookup"><span data-stu-id="36cc6-149">This will allow us to ‘apply’ the migration to the local database without trying to recreate all the tables etc. that already exist.</span></span>
3.  <span data-ttu-id="36cc6-150">在 Package Manager Console 中运行 "**更新数据库**" 命令。</span><span class="sxs-lookup"><span data-stu-id="36cc6-150">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="36cc6-151">这会将 InitialCreate 迁移应用到数据库。</span><span class="sxs-lookup"><span data-stu-id="36cc6-151">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="36cc6-152">由于实际的迁移不包含任何更改（因为我们暂时注释它们），因此它只是将一行添加到 \_\_MigrationsHistory 表，指示已应用此迁移。</span><span class="sxs-lookup"><span data-stu-id="36cc6-152">Since the actual migration doesn’t contain any changes (because we temporarily commented them out), it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>
4.  <span data-ttu-id="36cc6-153">取消注释 Up 方法中的代码。</span><span class="sxs-lookup"><span data-stu-id="36cc6-153">Un-comment the code in the Up method.</span></span> <span data-ttu-id="36cc6-154">这意味着，将此迁移应用于未来的数据库时，迁移将创建本地数据库中已经存在的架构。</span><span class="sxs-lookup"><span data-stu-id="36cc6-154">This means that when this migration is applied to future databases, the schema that already existed in the local database will be created by migrations.</span></span>

## <a name="things-to-be-aware-of"></a><span data-ttu-id="36cc6-155">注意事项</span><span class="sxs-lookup"><span data-stu-id="36cc6-155">Things to be aware of</span></span>

<span data-ttu-id="36cc6-156">对现有数据库使用迁移时，需要注意几个事项。</span><span class="sxs-lookup"><span data-stu-id="36cc6-156">There are a few things you need to be aware of when using Migrations against an existing database.</span></span>

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a><span data-ttu-id="36cc6-157">默认/计算的名称可能与现有架构不匹配</span><span class="sxs-lookup"><span data-stu-id="36cc6-157">Default/calculated names may not match existing schema</span></span>

<span data-ttu-id="36cc6-158">迁移时，迁移会显式指定列和表的名称基架。</span><span class="sxs-lookup"><span data-stu-id="36cc6-158">Migrations explicitly specifies names for columns and tables when it scaffolds a migrations.</span></span> <span data-ttu-id="36cc6-159">但是，在应用迁移时，迁移会为其他数据库对象计算默认名称。</span><span class="sxs-lookup"><span data-stu-id="36cc6-159">However, there are other database objects that Migrations calculates a default name for when applying the migrations.</span></span> <span data-ttu-id="36cc6-160">这包括索引和外键约束。</span><span class="sxs-lookup"><span data-stu-id="36cc6-160">This includes indexes and foreign key constraints.</span></span> <span data-ttu-id="36cc6-161">当以现有架构为目标时，这些计算的名称可能与数据库中实际存在的名称不匹配。</span><span class="sxs-lookup"><span data-stu-id="36cc6-161">When targeting an existing schema, these calculated names may not match what actually exists in your database.</span></span>

<span data-ttu-id="36cc6-162">下面是需要注意的一些示例：</span><span class="sxs-lookup"><span data-stu-id="36cc6-162">Here are some examples of when you need to be aware of this:</span></span>

<span data-ttu-id="36cc6-163">**如果使用步骤3中的 "选项一：使用现有架构作为起点"：**</span><span class="sxs-lookup"><span data-stu-id="36cc6-163">**If you used ‘Option One: Use existing schema as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="36cc6-164">如果模型中的未来更改需要更改或删除一个名为不同的数据库对象，则需要修改基架迁移来指定正确的名称。</span><span class="sxs-lookup"><span data-stu-id="36cc6-164">If future changes in your model require changing or dropping one of the database objects that is named differently, you will need to modify the scaffolded migration to specify the correct name.</span></span> <span data-ttu-id="36cc6-165">迁移 Api 有一个可选的 Name 参数，可让你执行此操作。</span><span class="sxs-lookup"><span data-stu-id="36cc6-165">The Migrations APIs have an optional Name parameter that allows you to do this.</span></span>
    <span data-ttu-id="36cc6-166">例如，你的现有架构可能有一个带有 BlogId 外键列的 Post 表，该表的索引名为 IndexFk\_BlogId。</span><span class="sxs-lookup"><span data-stu-id="36cc6-166">For example, your existing schema may have a Post table with a BlogId foreign key column that has an index named IndexFk\_BlogId.</span></span> <span data-ttu-id="36cc6-167">但是，默认情况下，迁移应将此索引命名为 IX\_BlogId。</span><span class="sxs-lookup"><span data-stu-id="36cc6-167">However, by default Migrations would expect this index to be named IX\_BlogId.</span></span> <span data-ttu-id="36cc6-168">如果对模型进行更改，导致删除此索引，则需要修改基架 DropIndex 调用以指定 IndexFk\_BlogId 名称。</span><span class="sxs-lookup"><span data-stu-id="36cc6-168">If you make a change to your model that results in dropping this index, you will need to modify the scaffolded DropIndex call to specify the IndexFk\_BlogId name.</span></span>

<span data-ttu-id="36cc6-169">**如果使用步骤3中的 "Option 2：使用空数据库作为起始点"：**</span><span class="sxs-lookup"><span data-stu-id="36cc6-169">**If you used ‘Option Two: Use empty database as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="36cc6-170">尝试对本地数据库运行初始迁移的关闭方法（即，恢复为空数据库）可能会失败，因为迁移将尝试使用错误的名称删除索引和外键约束。</span><span class="sxs-lookup"><span data-stu-id="36cc6-170">Trying to run the Down method of the initial migration (that is, reverting to an empty database) against your local database may fail because Migrations will try to drop indexes and foreign key constraints using the incorrect names.</span></span> <span data-ttu-id="36cc6-171">这只会影响本地数据库，因为将使用初始迁移的 Up 方法从头开始创建其他数据库。</span><span class="sxs-lookup"><span data-stu-id="36cc6-171">This will only affect your local database since other databases will be created from scratch using the Up method of the initial migration.</span></span>
    <span data-ttu-id="36cc6-172">如果要将现有的本地数据库降级到空状态，可以通过删除数据库或删除所有表，手动执行此操作，这是最简单的方法。</span><span class="sxs-lookup"><span data-stu-id="36cc6-172">If you want to downgrade your existing local database to an empty state it is easiest to do this manually, either by dropping the database or dropping all the tables.</span></span> <span data-ttu-id="36cc6-173">在此初始降级后，将用默认名称重新创建所有数据库对象，因此，此问题不会再次出现。</span><span class="sxs-lookup"><span data-stu-id="36cc6-173">After this initial downgrade all database objects will be recreated with the default names, so this issue will not present itself again.</span></span>
-   <span data-ttu-id="36cc6-174">如果您的模型中的未来更改需要更改或删除一个名为不同的数据库对象，则这对您的现有本地数据库不起作用，因为这些名称与默认值不匹配。</span><span class="sxs-lookup"><span data-stu-id="36cc6-174">If future changes in your model require changing or dropping one of the database objects that is named differently, this will not work against your existing local database – since the names won’t match the defaults.</span></span> <span data-ttu-id="36cc6-175">但是，它将适用于 "从头开始创建" 的数据库，因为它们将使用迁移选择的默认名称。</span><span class="sxs-lookup"><span data-stu-id="36cc6-175">However, it will work against databases that were created ‘from scratch’ since they will have used the default names chosen by Migrations.</span></span>
    <span data-ttu-id="36cc6-176">您可以在本地现有数据库上手动进行这些更改，也可以考虑让迁移从头开始重新创建数据库，因为它将在其他计算机上进行。</span><span class="sxs-lookup"><span data-stu-id="36cc6-176">You could either make these changes manually on your local existing database, or consider having Migrations recreate your database from scratch – as it will on other machines.</span></span>
-   <span data-ttu-id="36cc6-177">使用初始迁移的 Up 方法创建的数据库可能与本地数据库略有不同，因为将使用计算的索引和外键约束的默认名称。</span><span class="sxs-lookup"><span data-stu-id="36cc6-177">Databases created using the Up method of your initial migration may differ slightly from the local database since the calculated default names for indexes and foreign key constraints will be used.</span></span> <span data-ttu-id="36cc6-178">你还可能最终会获得额外的索引，因为迁移将默认在外键列上创建索引-这可能不是你的原始本地数据库中的情况。</span><span class="sxs-lookup"><span data-stu-id="36cc6-178">You may also end up with extra indexes as Migrations will create indexes on foreign key columns by default – this may not have been the case in your original local database.</span></span>

### <a name="not-all-database-objects-are-represented-in-the-model"></a><span data-ttu-id="36cc6-179">不是所有数据库对象都是在模型中表示的</span><span class="sxs-lookup"><span data-stu-id="36cc6-179">Not all database objects are represented in the model</span></span>

<span data-ttu-id="36cc6-180">不属于您的模型的数据库对象将不会被迁移处理。</span><span class="sxs-lookup"><span data-stu-id="36cc6-180">Database objects that are not part of your model will not be handled by Migrations.</span></span> <span data-ttu-id="36cc6-181">这可能包括视图、存储过程、权限、不是模型一部分的表、附加索引等。</span><span class="sxs-lookup"><span data-stu-id="36cc6-181">This can include views, stored procedures, permissions, tables that are not part of your model, additional indexes, etc.</span></span>

<span data-ttu-id="36cc6-182">下面是需要注意的一些示例：</span><span class="sxs-lookup"><span data-stu-id="36cc6-182">Here are some examples of when you need to be aware of this:</span></span>

-   <span data-ttu-id="36cc6-183">无论你在 "步骤 3" 中选择哪个选项，如果将来对模型进行更改，则需要更改或删除这些其他对象迁移将不知道进行这些更改。</span><span class="sxs-lookup"><span data-stu-id="36cc6-183">Regardless of the option you chose in ‘Step 3’, if future changes in your model require changing or dropping these additional objects Migrations will not know to make these changes.</span></span> <span data-ttu-id="36cc6-184">例如，如果您删除了一个具有其他索引的列，迁移将不知道删除该索引。</span><span class="sxs-lookup"><span data-stu-id="36cc6-184">For example, if you drop a column that has an additional index on it, Migrations will not know to drop the index.</span></span> <span data-ttu-id="36cc6-185">你将需要手动将其添加到基架迁移。</span><span class="sxs-lookup"><span data-stu-id="36cc6-185">You will need to manually add this to the scaffolded Migration.</span></span>
-   <span data-ttu-id="36cc6-186">如果使用了 "Option 2：使用空数据库作为起始点"，则将不会通过初始迁移的 "向上" 方法创建这些附加的对象。</span><span class="sxs-lookup"><span data-stu-id="36cc6-186">If you used ‘Option Two: Use empty database as a starting point’, these additional objects will not be created by the Up method of your initial migration.</span></span>
    <span data-ttu-id="36cc6-187">如果需要，可以修改向上和向下方法来处理这些额外的对象。</span><span class="sxs-lookup"><span data-stu-id="36cc6-187">You can modify the Up and Down methods to take care of these additional objects if you wish.</span></span> <span data-ttu-id="36cc6-188">对于迁移 API 中不是本机支持的对象（如视图），可以使用[Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx)方法运行原始 Sql 来创建/删除它们。</span><span class="sxs-lookup"><span data-stu-id="36cc6-188">For objects that are not natively supported in the Migrations API – such as views – you can use the [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) method to run raw SQL to create/drop them.</span></span>
